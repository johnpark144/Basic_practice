<!-- CSS를 따로 빼기  -->
<link rel="stylesheet" href="style.css">

<!-- 전체지정 (기본값이 들어있기 때문에 가끔씩 필요함) -->
*{
  margin: 0px;
  padding: 0px;
  box-sizing: border-box;

  body{
    font-family: serif;
  }
}

<!-- 단축키  -->
div*5
<div></div>
<div></div>
<div></div>
<div></div>
<div></div>

(li>a)*5
<li><a href=""></a></li>
<li><a href=""></a></li>
<li><a href=""></a></li>
<li><a href=""></a></li>
<li><a href=""></a></li>

<!-- href 새로고침 방지  -->
<li><a href="#"></a></li>

<!--##### 하위태그 속성 #########################################################################################################################################-->
.imgContainer > img  <!-- 상위태그 > 하위태그 -->
.addBtn:nth-child(1) <!-- 상위태그:nth-child(몇번째태그) -->

<!--##### Flexbox (display: flex; ) ###################################################################################### container 속성값 ###################-->

flex-direction: row; <!-- 디폴트는 row -->
flex-wrap: wrap; <!-- 창이 줄어들때 자동으로 다음칸으로 이동 (디폴트는 nowrap)-->
flex-flow: column nowrap; <!-- flex-direction + flex-wrap 같이쓸때  -->

<!-- justify-content은 flex-direction와 같은축으로 정렬해줌
  (row면 가로로 가운데정렬, column이면 세로로 가운데정렬)-->
justify-content: flex-end; <!-- 오른쪽정렬 (디폴트는 flex-start)  -->

justify-content: space-around; <!-- 좌우 포함하여 사이에 일정하게 공간을 줌으로 가운공간이 큼  -->
justify-content: space-evenly; <!-- 좌우 포함하여 똑같은 간격으로 사이에 일정하게 공간을 줌  -->
justify-content: space-between; <!-- 좌우는 옆으로 붙이고 사이사이 일정하게 공간을 줌  -->

<!-- align-items은 flex-direction의 반대축으로 정렬해줌
  (row면 세로로 가운데정렬, column이면 가로로 가운데정렬)-->
align-items: flex-end; <!-- 아래로정렬  (디폴트는 flex-start)-->
align-items: center;
align-items: baseline;<!-- item들의 크기가 달라져도 중심으로하여 맞춰줌 -->

align-self: center; <!-- align-items는 태그내부 정렬, align-self는 해당 태그 그 자체를 정렬 -->

align-content: space-between;

<!--################################################################################################################################ Item 속성값 ##################-->

flex-grow : 1 <!-- 디스플레이 크기가 커질때 화면에서 더 많이 커짐 (숫자는 비율) -->
flex-shrink : 1  <!-- 디스플레이 크기가 작아질때 화면에서 더 많이 줄어듬 (숫자는 비율) -->
flex-basis: 10% <!-- 화면전체의 비율 -->

align-self: center <!-- 아이템 따로 정렬  -->


<!--###### Position (display: inline, block, inline-block; 만 사용가능 ) <span>디폴트는 inline, <div>디폴트는 block #####################################################-->
<!-- Position: static;이 기본값 -->
<!-- relative는 원래있어야할 곳에서 -->
Position: relative;
top:20px;
left:20px;

<!-- absolute는 부모의 0,0에서 절대값으로 지정 -->
Position: absolute;
top:20px;
left:20px;

<!-- fixed는 window에서 절대값으로 지정 -->
Position: fixed;
top:20px;
left:20px;

<!-- sticky는 원래있어야할 곳에서 스크롤될때 벽에 붙음 -->
Position: sticky;

<!--####### 기타 ################################################################################################################################################-->

<!-- 마우스를 특정 id에 올려놨을때 (hover)  -->
#abc:hover {
  background-color: #fefefe;
}

<!-- CSS 안에서 변수 지정 -->
:root{
  --text-color: #f0f4f5;
  --background-color: #222222;
  --nav-size: 60px;
}

a{
  color: var(--text-color);
  width: calc(var(--nav-size) * 0.8); <!-- calc는 css안에서 계산해줌 -->
}

<!-- 스크롤 내릴때 한부분은 고정 -->
background: url(https://www.starbucks.co.kr/common/img/main/fav_prod_bg_new.jpg) fixed;

<!-- 스크롤 상관없이 가운데 배치하는 방법들  -->
#abc {
  display: grid;
  place-items: center;
  align-content: center;
  min-height: 100vh;
}
#abc{
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translateX(-50%);
}
#abc{
    display: block;
    margin: 0 auto;
}

<!-- 모달을 가운데로  -->
position: fixed;
top: 0;
bottom: 0;
left: 0;
right: 0;
margin: auto;
padding: 50px 30px 55px 30px;



<!--####### media쿼리 container쿼리 ################################################################################################################################################-->
<!--
Break-points 기준 (Sass에서는 변수로 지정해두면 편리)
--Mobile: 576px;
--Tablet: 768px;
--Laptop: 992px;
--Desktop: 1200px;
-->
<!-- media쿼리 (700px이하로 줄어들때 max-width) -->
@media screen and (max-width: 700px){
  .navbar{
    flex-directionL column;
  }
}

<!-- width값 크기 확인 -->
<body>
    <div id="size">
    </div>
</body>
</html>

<script>
    window.onload = screen; // 처음에 로드 되자마자 함수실행
    window.onresize = screen; // window size가 조정될때 함수실행

    function screen(){
        myWidth = window.innerWidth; // window의 width값

        document.getElementById('size').innerHTML
        = "Width : " + myWidth;
    }
</script>

<!-- container쿼리 (태그가 350px이하로 줄어들때 max-width) -->
@container (max-width: 350px){
  .title{
    font-size:15px;
  }
}


<!--######## 애니메이션 ############################################################################################## transition #########################-->
<!-- 설명:  https://inpa.tistory.com/entry/CSS-%F0%9F%93%9A-%ED%8A%B8%EB%9E%9C%EC%A7%80%EC%85%98-%ED%8A%B8%EB%9E%9C%EC%8A%A4%ED%8F%BC-%EC%95%A0%EB%8B%88%EB%A9%94%EC%9D%B4%EC%85%98 -->
<!-- transition는 프로퍼티 값의 변화가 일정 시간(duration)에 걸쳐 일어나도록해줌        // transition 속도 확인:  https://cubic-bezier.com/ -->

#py{
    width: 200px;
    transition-property: width, height; <!-- width, height 변환할때 -->
    transition-duration: 2s; <!-- 2초걸리면서 -->
    transition-delay: 1s; <!-- 1초뒤에시작 -->

    transition-timing-function: ease; <!-- 아늑하게 -->
    transition-timing-function: ease-in; <!-- 끝이빠름 -->
    transition-timing-function: ease-out; <!-- 시작이빠름 -->
    transition-timing-function: ease-in-out; <!-- 중간이빠름 -->

    transition: width 2s 1s ease-in-out; <!-- property(all), duration, delay, timing-function(cubic-bezier) 동시에 -->
  }

#py:hover{
  width: 400px;
}
<!-- 형제 태그에   -->
#py:hover ~ .pySibling{
  width: 400px;
}

<!--############################################################################################################### transform, Animation ##################-->
<!-- Transform은 요소에 이동(translate), 회전(rotate), 확대축소(scale), 비틀기(skew) 효과를 부여하기 위한 함수를 제공한다.
애니메이션 효과를 부여할 필요가 있다면 transition을 이용하거나, Transform에 애니메이션과 함께 사용해야한다.-->

.parent{
    background-color: navy;
    height: 400px;
    width: 400px;
}

.child{
    background-color: red;
    height: 50%;
    width: 50%;
    animation: moves 1s ease-in forwards infinite alternate; 
}<!--animation에 keyframes이름을 지정가능, animate.css라이브러리 사용해서 입력가능 ->  // npm i animate.css // https://animate.style/ 
forwards는실행후 머물러있게 animation-fill-mode(forward,both,backwards...),
횟수(infinite,1,2,3..),
번갈아가며반복(alternate) -->

.parent:hover .child{
    animation-play-state: paused <!-- 마우스 hover될때 멈추도록 -->
}

@keyframes moves{ <!--moves는 내가지정한 동작의 효과 -->
    0%{
        background-color: red;
        transform: translateX(0);
    }
    33%{
        transform: translateY(100%);
    }
    66%{
        transform: translateX(100%) translateY(100%);
    }
    100%{
        background-color: green;
        transform: translateX(100%);
    }
}

<!--########################################################################################### 스크롤을 내려 화면이 보일때 효과(IntersectionObserver)  #############-->
<style>
        .parent {
            display: grid;
            place-items: center;
            align-content: center;
            min-height: 100vh;
        }
        .hidden{
            opacity: 0;
            filter: blur(1px);
            transform: translateX(-100%);
            transition: all 1s;
        }
        .show{
            background-color: aquamarine;
            width: 200px;
            height:  200px;
            opacity: 1;
            filter: blur(0);
            transform: translateX(0);
        }

         .logo:nth-child(2){ /* 몇번째 자식에게 줄 효과인지 */
            transition-delay: 200ms;
        }
        .logo:nth-child(3){
            transition-delay: 400ms;
        }
        .logo:nth-child(4){
            transition-delay: 600ms;
        }
</style>
<body>
    <div class="parent">
        <div class="logo hidden">
            logo 1
        </div>
        <div class="logo hidden">
            logo 2
        </div>
        <div class="logo hidden">
            logo 3
        </div>
        <div class="logo hidden">
            logo 4
        </div>
    </div>
</body>
<script>
    const observer = new IntersectionObserver((entries) =>{
        entries.forEach((entry=>{
            if(entry.isIntersecting){
                entry.target.classList.add('show');
            } else {
                entry.target.classList.remove('show');
            }
        }))
    })
    const hiddenElem = document.querySelectorAll('.hidden');
  
    hiddenElem.forEach((el) => observer.observe(el));
</script>


<!--########################################################################################### 스크롤을 내려 화면이 보일때 효과(window.scrollY)  #############-->
<style>
h1{
        font-size: 5em;
        width: 258px;
        color: aliceblue;
        font-family: sans-serif;
        position: absolute;
        top: 80px;
        left: 200px;
        animation: slideIn 2s ease-in-out forwards;
  }

  @keyframes slideIn{
      from{
          left: -100px;
          filter: blur(10px);
          opacity: 0;
      }
      to{
          left: 200px;
          filter: blur(0);
          opacity: 1;
      }
  }

  @keyframes slideOut{
      from{
          left: 200px;
          filter: blur(0);
          opacity: 1;
      }
      to{
          left: -100px;
          filter: blur(10px);
          opacity: 0;
      }
  }
</style>
<body>
    <section>
        <h1>PICK YOUR FAVORITE</h1>
    </section>
</body>
<script>
    let mainText = document.querySelector('h1')
    window.addEventListener('scroll', ()=>{
        let value = window.scrollY // scroll Y좌표
        if(value>330){
            mainText.style.animation='slideOut 1s ease-in-out forwards'
        }else{
            mainText.style.animation='slideIn 2s ease-in-out forwards'
        }
    })
</script>

<!-- ############################################################################################################################### -->
<!-- ######## 기타 HTML / CSS 유용한것 ############################################################################################## -->
<!-- ############################################################################################################################### -->

<!-- ######## 모바일 가로스크롤, 확대 방지 ############################################################################################## -->
<meta content="yes" name="apple-mobile-web-app-capable" /> // 애플폰 전용으로
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1, minimum-scale=1 user-scalable=no">
// initial-scale=1.0  // 초기 크기를 설정합니다.
// user-scalable=no // 확대 기능을 사용하지 않습니다.
// maximum-scale=1 // 최대 배율, 크기를 설정합니다.
// width=device-width  // 화면이 표현하는 사이즈를 디바이스 사이즈에 맞춥니다.
    
<!-- ######## 박스 그림자 ############################################################################################################ -->
box-shadow: 1px 1px 10px 10px gray;

// box-shadow: x-position y-position blur spread color | inset | initial | inherit

// none : 그림자 효과를 없앤다.
// x-position : 가로 위치이다. 양수면 오른쪽에, 음수면 왼쪽에 그림자가 만들어진다. (필수)
// y-position : 세로 위치이다. 양수면 아래쪽에, 음수면 위쪽에 그림자가 만들어진다. (필수)
// blur : 그림자를 흐릿하게 만든다. 값이 클 수록 더욱 흐려진다.
// spread : 양수면 그림자를 확장하고, 음수면 축소한다.
// color : 그림자 색을 정한다.
// inset : 그림자를 요소의 안쪽에 만든다.
// initial : 기본값으로 설정한다.
// inherit : 부모 요소의 값을 상속받는다.

<!-- ######## 읽기 전용 ############################################################################################################ -->
<input
  value={selected}
  readOnly
/>

<!-- ######## 태그 없애기 ############################################################################################################ -->
1. display:none / display:block // 차지하던 공간까지 사라짐.
2. visibility:hidden / visibility:visible // 공간은 차지
3. obsesity:0 / obsesity:1 // 투명도 (공간 차지)

<!-- ######## 텍스트 대문자  ########################################################################################################### -->
text-transform: capitalize;  // 첫글자만 대문자
text-transform: uppercase;  // 전체 대문자

<!-- ######## 글자마다 간격  ########################################################################################################### -->
letter-spacing: 2px;

<!-- ######## 글자 줄간격(행간)  ########################################################################################################### -->
 line-height: 40px;

<!-- ###### 텍스트 그라데이션 하는방법 ################################################################################################## -->
background-image: linear-gradient(-45deg, var(--gradient)); // 45도 꺽어서 배경 그라데이션

    background-clip: text;
    -webkit-background-clip: text;  // 텍스트 부분만 잘라냄
    -webkit-text-fill-color: transparent;   // 텍스트에도 배경 컬러를 입힘

<!-- ###### 배경화면 고정 ################################################################################################## -->
background: url("https://user-images.githubusercontent.com/106279616/217299126-32003695-2bbe-4099-bcf7-8795ccc0331f.jpg") fixed;

<!-- ###### 스크롤 색상 및 속성 변경 ################################################################################################## -->
/* 스크롤 전체 */
::-webkit-scrollbar {
  width: 20px;
  background: rgba(var(--navyRgba), 0.3);
}

/* 스크롤 Track */
::-webkit-scrollbar-track {
  box-shadow: inset 0 0 5px #0a1c3f;
  border-radius: 8px;
}

/* 스크롤 thumb */
::-webkit-scrollbar-thumb {
  background: var(--navy);
  border-radius: 8px;
}

