<!--##### 리마인더 #########################################################################################################################################-->
box-sizing: border-box;
htmlFor 속성
Emmet (태그 빨리 )
그리드 align 같은거

<!--######### 인덱스 (Ctrl + F) ########################################################### (-> 인덱스에 있는데 찾기 안되면 찾아서 인덱스 변경) ##################-->
// 하위태그 속성 -- & >, nth-child
// Flexbox -- 다음칸으로, wrap, justify-content, align-items, baseline, align-self, order, flex-grow, flex-basis, align-self
// Grid -- 가로새로 배치 및 마진, grid-template-column, grid-auto-rows, grid-gap, 자리 차지, 이름 지정하여 자리배치, grid-template-areas, 전체 화면 그리드로 맞추기
// Position
// media쿼리 -- Break-points
// 애니메이션 -- translate, rotate, scale, skew, 스크롤을 내려 화면이 보일때 효과, IntersectionObserver, window.scrollY

// CSS를 따로 빼기
// 전체지정
// 단축키로 태그생성
// href 새로고침 방지
// CSS 안에서 변수 지정 -- :root{
// 스크롤 내릴때 배경 고정 -- fixed
// 스크롤 상관없이 가운데 배치
// 모달을 가운데로
// 모바일 가로스크롤, 확대 방지
// 박스 그림자
// 읽기 전용
// 태그 없애기 -- display:none, visibility:hidden, obsesity:0
// 텍스트 대문자
// 글자마다 간격
// 글자 줄간격
// 텍스트 그라데이션
// 스크롤 색상 및 속성 변경
// object-fit

<!--######### Html, CSS 관한 정보 링크 ####################################################################################################################-->





<!--##### 하위태그 속성 #########################################################################################################################################-->
.imgContainer > img  <!-- 상위태그 > 하위태그 -->
& > img  <!-- 해당태그 > 하위태그 -->
.addBtn:nth-child(1) <!-- 상위태그:nth-child(몇번째태그) -->

<!--##### Flexbox (display: flex; ) ###################################################################################### container 속성값 ###################-->

flex-direction: row; <!-- 디폴트는 row -->
flex-wrap: wrap; <!-- 창이 줄어들때 자동으로 다음칸으로 이동 (디폴트는 nowrap)-->
flex-flow: column nowrap; <!-- flex-direction + flex-wrap 같이쓸때  -->

<!-- justify-content은 flex-direction와 같은축으로 정렬해줌
  (row면 가로로 가운데정렬, column이면 세로로 가운데정렬)-->
justify-content: flex-end; <!-- 오른쪽정렬 (디폴트는 flex-start)  -->

justify-content: space-around; <!-- 좌우 포함하여 사이에 일정하게 공간을 줌으로 가운공간이 큼  -->
justify-content: space-evenly; <!-- 좌우 포함하여 똑같은 간격으로 사이에 일정하게 공간을 줌  -->
justify-content: space-between; <!-- 좌우는 옆으로 붙이고 사이사이 일정하게 공간을 줌  -->

<!-- align-items은 flex-direction의 반대축으로 정렬해줌
  (row면 세로로 가운데정렬, column이면 가로로 가운데정렬)-->
align-items: flex-end; <!-- 아래로정렬  (디폴트는 flex-start)-->
align-items: center;
align-items: baseline;<!-- item들의 크기가 달라져도 중심으로하여 맞춰줌 -->

align-self: center; <!-- align-items는 태그내부 정렬, align-self는 해당 태그 그 자체를 정렬 -->

<!--################################################################################################################################ Item 속성값 ##################-->
order : 1(첫번쨰순서) <!-- flex안 Item의 순서도 바꿔줄 수 있음 -->
flex-grow : 1  <!-- 디스플레이 크기가 커질때 화면에서 더 많이 커짐 (숫자는 비율) -->
flex-shrink : 1  <!-- 디스플레이 크기가 작아질때 화면에서 더 많이 줄어듬 (숫자는 비율) -->
flex-basis: 10% <!-- 화면전체의 비율 -->

align-self: center <!-- 아이템 따로 정렬  -->


<!--##### Grid (display: Grid; ) ##########################################################################################################################-->
<!-- 그리드는 전체 개요를 잡을때와, 표 같은 규칙적인 배치가 필요할때 사용 -->
<!-- 유용한 도구 링크 : https://cssgrid-generator.netlify.app/?fbclid=IwAR2xX6U6DfhzDHmjXMiyBeiYhXr9m094SKHrIOYHu3zghabCudQpb4cwSFc -->
<!-- ######################################################################################################## 가로새로 배치 및 마진 (그리드 선언태그에) #####  -->

.container {
  display: grid;
  <!-- columns 가로(width) -->
  grid-template-columns: 100px 100px 100px; <!-- 반응형시 비추 방법 -->
  grid-template-columns: 1fr 1fr 1fr;  <!-- 비율로 (1배 1배 1배)  -->
  grid-template-columns: repeat(5, 20%); <!-- 반복되는경우  -->

  <!-- rows 세로(height) 순서대로 값을 줌 -->
  grid-template-rows: 100px 200px 100px 300px;

  <!-- rows 세로(height)가 몇줄인지 모를 때 개수 상관없이 -->
  grid-auto-rows: 150px;
  grid-auto-rows: minmax(150px, auto);  <!-- 빈칸도 150px를 유지하되 내용이 넘칠때 유동적으로 같이 커짐 -->

  <!-- 사이마다 갭 주기 (마진)  -->
  grid-gap: 10px; <!-- 전체 갭 -->
  grid-column-gap: 10px; <!-- column 으로써의 갭 (좌우 갭) -->
  grid-row-gap: 10px; <!-- row 으로써의 갭 (상하 갭) -->
}


<!-- #################################################################################################### 자리 차지 (그리드 선언태그의 자식태그) #############  -->
.item2 {
  background-color: #a9c7d8;
  grid-column: 2 / 4; <!-- grid-column-start: 2;,  grid-column-end: 4; 와 동일 -->
  grid-row: 1 / 3; <!-- grid-row-start: 1;,  grid-row-end: 3; 와 동일 -->
}

<!--
예시 (grid-row도 아래방향으로 이와 같음)
grid-column: 2 / 4;  
= grid-column: 2 / span 2;   -> 2부터 2개더 차지하라는 
= grid-column: 2 / -3;   

(2부터 4까지 차지)
1     2     3     4     5     6
|     |||||||||||||     |     |
-6    -5    -4    -3    -2    -1     
 -->

<!-- ############################################################################################################ 이름 지정하여 자리배치 #############  -->

.container {
  display: grid;
  grid-template-columns: repeat(3, 1fr);
  grid-auto-rows: 150px;
  grid-gap: 1rem;
  <!-- 자리를 만들고 이름 지정  -->
  grid-template-areas:  
      'a a a'
      'b c c'
      'b d f'
      'e d g'
}

 <!-- 이름이 붙은 자리에 위치시킴  -->
.image1 {
  grid-area: a;
}
.image2 {
  grid-area: b;
}
.image3 {
  grid-area: c;
}
.image4 {
  grid-area: d;
}


<!-- #################################################################################################### 전체 화면 그리드로 맞추기 예시 #############  -->
<!-- Html -->
  <body>
    <header>header</header>
    <main>main</main>
    <aside>side</aside>
    <footer>footer</footer>
  </body>

<!-- Css -->
header, main, aside, footer {
  display: flex;
  justify-content: center;
  align-items: center;
}

body {
  width: 100vw;
  height: 100vh;
  margin: 0;
  display: grid;
  grid-template-columns: 3fr 1fr;
  grid-template-rows: 100px auto 50px;
  grid-template-areas: 
    'header header' 
    'main side' 
    'footer footer';
}

header {
  grid-area: header;
  background-color: black;
  color: white;
}

main {
  grid-area: main;
}

aside {
  grid-area: side;
  background-color: #ff9d00;
}

footer {
  grid-area: footer;
  background-color: black;
  color: white;
}


<!--###### Position  ##################################################################################################################################-->
<!-- Position: static;이 기본값 -->
<!-- relative는 원래있어야할 곳에서 -->
Position: relative;
top:20px;
left:20px;

<!-- absolute는 부모의 0,0에서 절대값으로 지정 -->
Position: absolute;
top:20px;
left:20px;

<!-- fixed는 window에서 절대값으로 지정 -->
Position: fixed;
top:20px;
left:20px;

<!-- sticky는 원래있어야할 곳에서 스크롤될때 벽에 붙음 -->
Position: sticky;


<!--####### media쿼리 container쿼리 ############################################################################################################################-->
<!--
Break-points 기준 (Sass에서는 변수로 지정해두면 편리)
--Mobile: 576px;
--Tablet: 768px;
--Laptop: 992px;
--Desktop: 1200px;
-->
<!-- media쿼리 (700px이하로 줄어들때 max-width) -->
@media screen and (max-width: 700px){
  .navbar{
    flex-directionL column;
  }
}

<!-- width값 크기 확인 -->
<body>
    <div id="size">
    </div>
</body>
</html>

<script>
    window.onload = screen; // 처음에 로드 되자마자 함수실행
    window.onresize = screen; // window size가 조정될때 함수실행

    function screen(){
        myWidth = window.innerWidth; // window의 width값

        document.getElementById('size').innerHTML
        = "Width : " + myWidth;
    }
</script>

<!-- container쿼리 (태그가 350px이하로 줄어들때 max-width) -->
@container (max-width: 350px){
  .title{
    font-size:15px;
  }
}


<!--######## 애니메이션 ############################################################################################## transition #########################-->
<!-- 설명:  https://inpa.tistory.com/entry/CSS-%F0%9F%93%9A-%ED%8A%B8%EB%9E%9C%EC%A7%80%EC%85%98-%ED%8A%B8%EB%9E%9C%EC%8A%A4%ED%8F%BC-%EC%95%A0%EB%8B%88%EB%A9%94%EC%9D%B4%EC%85%98 -->
<!-- transition는 프로퍼티 값의 변화가 일정 시간(duration)에 걸쳐 일어나도록해줌        // transition 속도 확인:  https://cubic-bezier.com/ -->

#py{
    width: 200px;
    transition-property: width, height; <!-- width, height 변환할때 -->
    transition-duration: 2s; <!-- 2초걸리면서 -->
    transition-delay: 1s; <!-- 1초뒤에시작 -->

    transition-timing-function: ease; <!-- 아늑하게 -->
    transition-timing-function: ease-in; <!-- 끝이빠름 -->
    transition-timing-function: ease-out; <!-- 시작이빠름 -->
    transition-timing-function: ease-in-out; <!-- 중간이빠름 -->

    transition: width 2s 1s ease-in-out; <!-- property(all), duration, delay, timing-function(cubic-bezier) 동시에 -->
  }

#py:hover{
  width: 400px;
}
<!-- 형제 태그에   -->
#py:hover ~ .pySibling{
  width: 400px;
}

<!--############################################################################################################### transform, Animation ##################-->
<!-- Transform은 요소에 이동(translate), 회전(rotate), 확대축소(scale), 비틀기(skew) 효과를 부여하기 위한 함수를 제공한다.
애니메이션 효과를 부여할 필요가 있다면 transition을 이용하거나, Transform에 애니메이션과 함께 사용해야한다.-->

.parent{
    background-color: navy;
    height: 400px;
    width: 400px;
}

.child{
    background-color: red;
    height: 50%;
    width: 50%;
    animation: moves 1s ease-in forwards infinite alternate; 
}<!--animation에 keyframes이름을 지정가능, animate.css라이브러리 사용해서 입력가능 ->  // npm i animate.css // https://animate.style/ 
forwards는실행후 머물러있게 animation-fill-mode(forward,both,backwards...),
횟수(infinite,1,2,3..),
번갈아가며반복(alternate) -->

.parent:hover .child{
    animation-play-state: paused <!-- 마우스 hover될때 멈추도록 -->
}

@keyframes moves{ <!--moves는 내가지정한 동작의 효과 -->
    0%{
        background-color: red;
        transform: translateX(0);
    }
    33%{
        transform: translateY(100%);
    }
    66%{
        transform: translateX(100%) translateY(100%);
    }
    100%{
        background-color: green;
        transform: translateX(100%);
    }
}

<!--########################################################################################### 스크롤을 내려 화면이 보일때 효과(IntersectionObserver)  #############-->
<style>
        .parent {
            display: grid;
            place-items: center;
            align-content: center;
            min-height: 100vh;
        }
        .hidden{
            opacity: 0;
            filter: blur(1px);
            transform: translateX(-100%);
            transition: all 1s;
        }
        .show{
            background-color: aquamarine;
            width: 200px;
            height:  200px;
            opacity: 1;
            filter: blur(0);
            transform: translateX(0);
        }

         .logo:nth-child(2){ /* 몇번째 자식에게 줄 효과인지 */
            transition-delay: 200ms;
        }
        .logo:nth-child(3){
            transition-delay: 400ms;
        }
        .logo:nth-child(4){
            transition-delay: 600ms;
        }
</style>
<body>
    <div class="parent">
        <div class="logo hidden">
            logo 1
        </div>
        <div class="logo hidden">
            logo 2
        </div>
        <div class="logo hidden">
            logo 3
        </div>
        <div class="logo hidden">
            logo 4
        </div>
    </div>
</body>
<script>
    const observer = new IntersectionObserver((entries) =>{
        entries.forEach((entry=>{
            if(entry.isIntersecting){
                entry.target.classList.add('show');
            } else {
                entry.target.classList.remove('show');
            }
        }))
    })
    const hiddenElem = document.querySelectorAll('.hidden');
  
    hiddenElem.forEach((el) => observer.observe(el));
</script>


<!--########################################################################################### 스크롤을 내려 화면이 보일때 효과(window.scrollY)  #############-->
<style>
h1{
        font-size: 5em;
        width: 258px;
        color: aliceblue;
        font-family: sans-serif;
        position: absolute;
        top: 80px;
        left: 200px;
        animation: slideIn 2s ease-in-out forwards;
  }

  @keyframes slideIn{
      from{
          left: -100px;
          filter: blur(10px);
          opacity: 0;
      }
      to{
          left: 200px;
          filter: blur(0);
          opacity: 1;
      }
  }

  @keyframes slideOut{
      from{
          left: 200px;
          filter: blur(0);
          opacity: 1;
      }
      to{
          left: -100px;
          filter: blur(10px);
          opacity: 0;
      }
  }
</style>
<body>
    <section>
        <h1>PICK YOUR FAVORITE</h1>
    </section>
</body>
<script>
    let mainText = document.querySelector('h1')
    window.addEventListener('scroll', ()=>{
        let value = window.scrollY // scroll Y좌표
        if(value>330){
            mainText.style.animation='slideOut 1s ease-in-out forwards'
        }else{
            mainText.style.animation='slideIn 2s ease-in-out forwards'
        }
    })
</script>

<!-- ############################################################################################################################### -->
<!-- ######## 그외 기타 HTML / CSS 유용한것 ############################################################################################## -->
<!-- ############################################################################################################################### -->
<!-- ######## CSS를 따로 빼기 ################################################################################################# -->
<link rel="stylesheet" href="style.css">

<!-- ######## 전체지정 ################################################################################################# -->
*{
  margin: 0px;
  padding: 0px;
  box-sizing: border-box;

  body{
    font-family: serif;
  }
}

<!-- ######## 단축키로 태그생성 (Emmet) ################################################################################################# -->
div*5
<div></div>
<div></div>
<div></div>
<div></div>
<div></div>

(li>a)*5
<li><a href=""></a></li>
<li><a href=""></a></li>
<li><a href=""></a></li>
<li><a href=""></a></li>
<li><a href=""></a></li>

<!-- ######## href 새로고침 방지 ################################################################################################# -->
<li><a href="#"></a></li>

<!-- ######## hover ################################################################################################# -->
#abc:hover {
  background-color: #fefefe;
}

<!-- ######## CSS 안에서 변수 지정 ################################################################################################# -->
:root{
  --text-color: #f0f4f5;
  --background-color: #222222;
  --nav-size: 60px;
}

a{
  color: var(--text-color);
  width: calc(var(--nav-size) * 0.8); <!-- calc는 css안에서 계산해줌 -->
}

<!-- ######## 스크롤 내릴때 배경 고정 ################################################################################################# -->
background: url(https://www.starbucks.co.kr/common/img/main/fav_prod_bg_new.jpg) fixed;

<!-- ####### 스크롤 상관없이 가운데 배치하는 방법들 ################################################################################################ -->
#abc {
  display: grid;
  place-items: center;
  align-content: center;
  min-height: 100vh;
}
#abc{
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translateX(-50%);
}
#abc{
    display: block;
    margin: 0 auto;
}

<!-- ######## 모달을 가운데로 ########################################################################################################## -->
position: fixed;
top: 0;
bottom: 0;
left: 0;
right: 0;
margin: auto;
padding: 50px 30px 55px 30px;

<!-- ######## 모바일 가로스크롤, 확대 방지 ############################################################################################## -->
<meta content="yes" name="apple-mobile-web-app-capable" /> // 애플폰 전용으로
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1, minimum-scale=1 user-scalable=no">
// initial-scale=1.0  // 초기 크기를 설정합니다.
// user-scalable=no // 확대 기능을 사용하지 않습니다.
// maximum-scale=1 // 최대 배율, 크기를 설정합니다.
// width=device-width  // 화면이 표현하는 사이즈를 디바이스 사이즈에 맞춥니다.
    
<!-- ######## 박스 그림자 ############################################################################################################ -->
box-shadow: 1px 1px 10px 10px gray;

// box-shadow: x-position y-position blur spread color | inset | initial | inherit

// none : 그림자 효과를 없앤다.
// x-position : 가로 위치이다. 양수면 오른쪽에, 음수면 왼쪽에 그림자가 만들어진다. (필수)
// y-position : 세로 위치이다. 양수면 아래쪽에, 음수면 위쪽에 그림자가 만들어진다. (필수)
// blur : 그림자를 흐릿하게 만든다. 값이 클 수록 더욱 흐려진다.
// spread : 양수면 그림자를 확장하고, 음수면 축소한다.
// color : 그림자 색을 정한다.
// inset : 그림자를 요소의 안쪽에 만든다.
// initial : 기본값으로 설정한다.
// inherit : 부모 요소의 값을 상속받는다.

<!-- ######## 읽기 전용 ############################################################################################################ -->
<input
  value={selected}
  readOnly
/>

<!-- ######## 태그 없애기 ############################################################################################################ -->
1. display:none / display:block // 차지하던 공간까지 사라짐.
2. visibility:hidden / visibility:visible // 공간은 차지
3. obsesity:0 / obsesity:1 // 투명도 (공간 차지)

<!-- ######## 텍스트 대문자  ########################################################################################################### -->
text-transform: capitalize;  // 첫글자만 대문자
text-transform: uppercase;  // 전체 대문자

<!-- ######## 글자마다 간격  ########################################################################################################### -->
letter-spacing: 2px;

<!-- ######## 글자 줄간격(행간)  ########################################################################################################### -->
 line-height: 40px;

<!-- ###### 텍스트 그라데이션 하는방법 ################################################################################################## -->
background-image: linear-gradient(-45deg, var(--gradient)); // 45도 꺽어서 배경 그라데이션

    background-clip: text;
    -webkit-background-clip: text;  // 텍스트 부분만 잘라냄
    -webkit-text-fill-color: transparent;   // 텍스트에도 배경 컬러를 입힘

<!-- ###### 스크롤 색상 및 속성 변경 ################################################################################################## -->
/* 스크롤 전체 */
::-webkit-scrollbar {
  width: 20px;
  background: rgba(var(--navyRgba), 0.3);
}

/* 스크롤 Track */
::-webkit-scrollbar-track {
  box-shadow: inset 0 0 5px #0a1c3f;
  border-radius: 8px;
}

/* 스크롤 thumb */
::-webkit-scrollbar-thumb {
  background: var(--navy);
  border-radius: 8px;
}

<!-- ###### object-fit ############################################################################################################ -->
object-fit: contain;  // 가로세로 비율 유지 함, 비율이 맞지 않는 경우엔 빈 자리가 남게 됨
object-fit: cover; // 가로세로 비율 유지 하되, 비율이 맞지 않는 경우엔 이미지를 확대해서 컨테이너를 완전히 채움.
object-fit: fill; // 기본값 // 주어진 너비와 높이에 딱 맞도록 조절합니다 // 가로세로 비율 유지 X
object-fit: none; // 본래의 이미지 사이즈를 유지, 그래도 이미지 가운데가 보여지도록 
object-fit: scale-down; // none 또는 contain 중에 더 적절한 방향으로 사이즈 조절
